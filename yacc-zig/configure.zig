const std = @import("std");
const builtin = @import("builtin");

const log = std.log.scoped(.main);

const Allocator = std.mem.Allocator;
const Dir = std.fs.Dir;
const File = std.fs.File;

const getEnv = std.process.getEnvVarOwned;

pub const std_options = struct {
    // Set the log level to info
    pub const log_level = .info;
};

fn equals(left: []const u8, right: []const u8) bool {
    return std.mem.order(u8, left, right) == .eq;
}

fn startsWith(left: []const u8, right: []const u8) bool {
    return std.mem.startsWith(u8, left, right);
}

fn concat(allocator: Allocator, slices: []const []const u8) ![]u8 {
    return std.mem.concat(allocator, u8, slices);
}

fn format(allocator: Allocator, comptime fmt: []const u8, args: anytype) ![]const u8 {
    var array = std.ArrayList(u8).init(allocator);
    try std.fmt.format(array.writer(), fmt, args);
    return array.toOwnedSlice();
}

fn openFile(path: Dir, sub_path: []const u8) File.OpenError!File {
    if (path.openFile(sub_path, .{ .mode = .write_only })) |file| {
        return file;
    } else |err| {
        switch (err) {
            error.FileNotFound => return path.createFile(sub_path, .{}),
            else => return err,
        }
    }
}

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    var prefix: []const u8 = getEnv(allocator, "PREFIX") catch "/usr/local";
    var mandir: []const u8 = getEnv(allocator, "MANDIR") catch try concat(allocator, &.{ prefix, "/man" });

    var instprog: []const u8 = "oyacc";
    var fix: []const u8 = "oyyfix";
    var static = false;

    var args = try std.process.argsWithAllocator(allocator);
    while (args.next()) |arg| {
        if (startsWith(arg, "--prefix=")) {
            prefix = arg[9..];
        } else if (startsWith(arg, "--mandir=")) {
            mandir = arg[9..];
        } else if (equals(arg, "--enable-yacc")) {
            instprog = "yacc";
            fix = "yyfix";
        } else if (equals(arg, "--disable-yacc")) {
            instprog = "oyacc";
            fix = "oyyfix";
        } else if (equals(arg, "--enable-static")) {
            static = true;
        } else if (equals(arg, "--disable-static")) {
            static = false;
        } else if (equals(arg, "-h") or equals(arg, "--help")) {
            log.info(
                \\Usage: configure [options]
                \\
                \\Options:
                \\  --help or -h            Display this help message
                \\  --prefix=PREFIX         Top level install directory is PREFIX [$prefix]
                \\  --mandir=MANDIR         Manual pages are installed to MANDIR [$mandir]
                \\  --enable-yacc           Install executable as yacc [default=no]
                \\  --enable-static         Statically link executables [default=no]
            , .{});

            std.process.exit(1);
        }
    }

    var cflags = if (getEnv(allocator, "CFLAGS")) |cflags|
        try concat(allocator, &.{ cflags, " " })
    else |_|
        "";

    var ldflags = if (getEnv(allocator, "LDFLAGS")) |ldflags|
        try concat(allocator, &.{ ldflags, " " })
    else |_|
        "";

    const path = std.fs.cwd();

    log.info("checking for C compiler...", .{});

    var cc = cccheck(allocator, path, cflags, ldflags) catch {
        log.err(
            \\not found
            \\Please install a C compiler and re-run configure.
        , .{});

        return error.CompilerNotFound;
    };

    log.info("checking for -w compiler flag...", .{});

    if (try wflagcheck(allocator, path, cc)) {
        log.info("no", .{});
    } else {
        cflags = try concat(allocator, &.{ cflags, " -w" });
        log.info("yes", .{});
    }

    log.info("checking for OS...", .{});

    const os = builtin.os.tag;
    if (os == .linux or os == .windows) {
        cflags = try concat(allocator, &.{ cflags, " -D_GNU_SOURCE -D__unused=" });
    } else if (os == .netbsd) {
        cflags = try concat(allocator, &.{ cflags, " -D_OPENBSD_SOURCE" });
    } else if (os == .aix) {
        cflags = try concat(allocator, &.{ cflags, " -D_ALL_SOURCE -D__unused=" });
        ldflags = "-lbsd";
    }

    const config_h = try openFile(path, "config.h");
    const config_h_writer = config_h.writer();
    _ = try config_h_writer.write("/* Autogenerated by configure */\n\n");

    log.info("checking for __dead...", .{});

    if (try conf_check(allocator, path, cc, cflags, ldflags,
        \\#include <stdlib.h>
        \\__dead void usage(void){exit(1);}int main(void){usage();return 0;}
    )) {
        log.info("yes", .{});
    } else {
        log.info("no", .{});
        log.info("checking for __dead2...", .{});

        if (try conf_check(allocator, path, cc, cflags, ldflags,
            \\#include <stdlib.h>
            \\__dead2 void usage(void){exit(1);}int main(void){usage();return 0;}
        )) {
            _ = try config_h_writer.write("#define __dead __dead2\n");
            log.info("yes", .{});
        } else {
            log.info("no", .{});
            log.info("checking for __attribute__((__noreturn__))...", .{});

            if (try conf_check(allocator, path, cc, cflags, ldflags,
                \\#include <stdlib.h>
                \\__attribute__((__noreturn__)) void usage(void){exit(1);}int main(void){usage();return 0;}
            )) {
                _ = try config_h_writer.write("#define __dead __attribute__((__noreturn__))\n");
                log.info("yes", .{});
            } else {
                _ = try config_h_writer.write("#define __dead\n");
                log.info("no", .{});
            }
        }
    }

    log.info("checking for __progname...", .{});

    if (try conf_check(allocator, path, cc, cflags, ldflags,
        \\#include <stdio.h>
        \\extern char *__progname;
        \\int main(void){fprintf(stderr, "%s\n", __progname);return 0;}
    )) {
        _ = try config_h_writer.write("#define HAVE_PROGNAME\n");
        log.info("yes", .{});
    } else {
        log.info("no", .{});
    }

    log.info("checking for asprintf...", .{});

    if (try conf_check(allocator, path, cc, cflags, ldflags,
        \\#include <stdio.h>
        \\int main(void){asprintf(NULL,NULL);return 0;}
    )) {
        _ = try config_h_writer.write("#define HAVE_ASPRINTF\n");
        log.info("yes", .{});
    } else {
        log.info("no", .{});
    }

    log.info("checking for pledge...", .{});

    if (try conf_check(allocator, path, cc, cflags, ldflags,
        \\#include <unistd.h>
        \\int main(void){pledge(NULL,NULL);return 0;}
    )) {
        _ = try config_h_writer.write("#define HAVE_PLEDGE\n");
        log.info("yes", .{});
    } else {
        log.info("no", .{});
    }

    log.info("checking for reallocarray...", .{});

    if (try conf_check(allocator, path, cc, cflags, ldflags,
        \\#include <stdlib.h>
        \\int main(void){reallocarray(NULL, 0, 0);return 0;}
    )) {
        _ = try config_h_writer.write("#define HAVE_REALLOCARRAY\n");
        log.info("yes", .{});
    } else {
        log.info("no", .{});
    }

    log.info("checking for strlcpy...", .{});

    if (try conf_check(allocator, path, cc, cflags, ldflags,
        \\#include <string.h>
        \\int main(void){strlcpy(NULL,NULL,0);return 0;}
    )) {
        _ = try config_h_writer.write("#define HAVE_STRLCPY\n");
        log.info("yes", .{});
    } else {
        log.info("no", .{});
    }

    log.info("creating Makefile...", .{});

    const makefile = try openFile(path, "Makefile");

    _ = try makefile.write(try format(allocator,
        \\# This Makefile automatically generated by configure.
        \\
        \\CC =		{s}
        \\CFLAGS =	{s}
        \\
    , .{ cc, cflags }));

    if (ldflags.len > 0) {
        _ = try makefile.write(try format(allocator,
            \\LDFLAGS =	{s}
            \\
        , .{ldflags}));
    }

    _ = try makefile.write(try format(allocator,
        \\PREFIX =	{s}
        \\MANDIR =	{s}
        \\PROG =		{s}
        \\
        \\OBJS =	closure.o error.o lalr.o lr0.o main.o mkpar.o output.o reader.o \\
        \\	skeleton.o symtab.o verbose.o warshall.o portable.o
        \\
        \\all: \${{PROG}}
        \\
        \\\${{PROG}}: \${{OBJS}}
        \\	\${{CC}} \${{LDFLAGS}} -o \${{PROG}} \${{OBJS}}
        \\
        \\install: all
        \\	install -d \${{DESTDIR}}\${{BINDIR}}
        \\	install -d \${{DESTDIR}}\${{MANDIR}}
        \\	install -m 555 \${{PROG}} \${{DESTDIR}}\${{BINDIR}}
        \\	install -m 555 yyfix.sh \${{DESTDIR}}\${{BINDIR}}/{s}
        \\	install -m 444 yacc.1 \${{DESTDIR}}\${{MANDIR}}/\${{PROG}}.1
        \\	install -m 444 yyfix.1 \${{DESTDIR}}\${{MANDIR}}/{s}.1
        \\
        \\test:
        \\	@echo "No tests"
        \\
        \\clean:
        \\	rm -f \${{PROG}} \${{OBJS}}
        \\
        \\distclean: clean
        \\	rm -f Makefile config.h
    , .{ prefix, mandir, instprog, fix, fix }));

    log.debug("prefix={s}", .{prefix});
    log.debug("mandir={s}", .{mandir});
    log.debug("instprog={s}", .{instprog});
    log.debug("fix={s}", .{fix});
    log.debug("static={}", .{static});
    log.debug("cflags={s}", .{cflags});
    log.debug("ldflags={s}", .{ldflags});
    log.debug("cc={s}", .{cc});
    log.debug("os={any}", .{os});

    log.info("done", .{});
}

fn cccheck(a: Allocator, path: Dir, cflags: []const u8, ldflags: []const u8) ![]const u8 {
    var ArenaAllocator = std.heap.ArenaAllocator.init(a);
    var allocator = ArenaAllocator.allocator();
    defer ArenaAllocator.deinit();

    if (getEnv(allocator, "CC")) |compiler| {
        if (try c_compiler_check(allocator, path, compiler, cflags, ldflags)) {
            return compiler;
        }
    } else |_| {}

    for ([_][]const u8{ "cc", "clang", "pcc", "xlc", "gcc" }) |compiler| {
        if (try c_compiler_check(allocator, path, compiler, cflags, ldflags)) {
            return compiler;
        }
    }

    return error.CompilerNotFound;
}

fn c_compiler_check(allocator: Allocator, path: Dir, compiler: []const u8, cflags: []const u8, ldflags: []const u8) !bool {
    const file = try openFile(path, "conftest.c");

    defer path.deleteFile("conftest") catch {};
    defer path.deleteFile("conftest.o") catch {};
    defer path.deleteFile("conftest.c") catch {};

    _ = try file.write("int main(void){return 0;}");

    const exec = std.process.Child.exec;

    if (exec(.{
        .allocator = allocator,
        .argv = &.{ compiler, cflags, ldflags, "-o", "conftest", "conftest.c" },
    })) |_| {
        if (exec(.{
            .allocator = allocator,
            .argv = &.{"./conftest"},
        })) |_| {
            return true;
        } else |_| {
            log.err(
                \\could not build working executables
                \\Please ensure your C compiler is a native compiler
            , .{});

            std.process.exit(1);
        }
    } else |_| {}

    return false;
}

fn wflagcheck(allocator: Allocator, path: Dir, cc: []const u8) !bool {
    const file = try openFile(path, "conftest.c");

    defer path.deleteFile("conftest") catch {};
    defer path.deleteFile("conftest.o") catch {};
    defer path.deleteFile("conftest.c") catch {};

    _ = try file.write("int main(void){return 0;}");

    const result = try std.process.Child.exec(.{
        .allocator = allocator,
        .argv = &.{ cc, "-w", "-o", "conftest", "conftest.c" },
    });

    for (result.stderr) |char| {
        if (char == ':') {
            return true;
        }
    }

    return false;
}

fn conf_check(allocator: Allocator, path: Dir, cc: []const u8, cflags: []const u8, ldflags: []const u8, source: []const u8) !bool {
    const file = try openFile(path, "conftest.c");

    defer path.deleteFile("conftest") catch {};
    defer path.deleteFile("conftest.o") catch {};
    defer path.deleteFile("conftest.c") catch {};

    _ = try file.write(source);

    const result = std.process.Child.exec(.{
        .allocator = allocator,
        .argv = &.{ cc, cflags, ldflags, "-o", "conftest", "conftest.c" },
    });

    return if (result) |_| true else |_| false;
}
